# diqtok-forge
Simulation of advanced attacks on ensemble based quantum token. More information can be found in the preprint https://arxiv.org/abs/2412.20243 on arXiv.

## Compilation

Compiling the library without mpi compiler

```bash
make
```

Compile the whole library with mpi compiler

```bash
make mpi
```

This is all. The default c++ compiler is g++ and mpi c++ compiler mpicxx. If you want to use a different compiler, change the Makefile accordingly.

## Usage

There is a master input file called control, which is used by all programs. The content of an example control file is shown below:

```bash
Nint  30
Nscan 35
N  300
nT 50
p0b 0.1003
p1b 0.9362
p0f 0.1003
p1f 0.9362
thetaf2 1 199 200
filename N1_nf1_thetaf2_pf2.dat
thetaf3     1 199 200
phif3   -199 199 200
```

* Nint defines the number of integration points for the numerical integration solver using the Gauss-Legendre quadrature. Values between 1 and 100 are possible.
* Nscan provides the number of points in the grid for scanning the angles theta and phi on the Bloch sphere.
* N defines the number of qubits in the quantum token
* nT is the photon count threshold, i.e., the maximal number of photons that can be detected by the bank during the verification of the quantum token.
* p0b: Probability that the bank detects a photon in a measurement, if the qubit is in the dark state 0.
* p1b: Probability that the bank detects a photon in a measurement, if the qubit is in the bright state 1.
* p0f: Probability that the forger detects a photon in a measurement, if the qubit is in the dark state 0.
* p1f: Probability that the forger detects a photon in a measurement, if the qubit is in the bright state 1.
* thetaf2: Three integer numbers $n_1$ $n_2$ $n_3$. For two or three measurements, the optimal angle thetaf2 is determined by scanning all thetaf2 angles on the grid $\frac{n_1}{n_3}\, \pi, \frac{n_1+1}{n_3}\, \pi, \ldots, \frac{n_2-1}{n_3}\, \pi, \frac{n_2}{n_3}\, \pi$.
* filename is the name of the file for the list output of N1, nf1, thetaf2 and pbf2. This is only relevant for determining the optimal forged token using two measurements. Here, all possible values for the number of qubits in the first measurement N1 are analyzed. In the second measurement, there are N2 = N-N1 qubits. knf1 is the measured number of photons in the first measurement of the forger. thetaf2 denotes the theta-angle for the second measurement. This angle is scanned over the above mentioned grid. pf2 is the bank acceptance rate of the forged token considering all possible measurement results nf2 in the second measurement, when in the first measurement N1 qubits were used, nf1 photons were detected and for the second measurement the angle thetaf2 was used.
* thetaf3: Three integer numbers $n_1$ $n_2$ $n_3$. For three measurements, the optimal angle thetaf3 is determined by scanning all thetaf3 angles on the grid $\frac{n_1}{n_3}\, \pi, \frac{n_1+1}{n_3}\, \pi, \ldots, \frac{n_2-1}{n_3}\, \pi, \frac{n_2}{n_3}\, \pi$.
* phif3: Three integer numbers $n_1$ $n_2$ $n_3$. For three measurements, the optimal angle phif3 is determined by scanning all phif3 angles on the grid $\frac{n_1}{n_3}\, \pi, \frac{n_1+1}{n_3}\, \pi, \ldots, \frac{n_2-1}{n_3}\, \pi, \frac{n_2}{n_3}\, \pi$.

Not all programs read all lines of the file. The library is organized as followed:

* integrate.cpp This c++ library can integrate any one- and multidimensional function using the Gaussian integration method. One can also get only the integration points and weights for n=1, 2,... , 100 integration points.
* qtokentools.cpp This c++ library contains many useful functions for calculating the acceptance probability of quantum tokens.
* pb_pf_0_1opt_3DIT_123ML.cpp This mpi-parallelized c++ program calculates the probabilty that the bank accepts a quantum token generated by itself and the probability of acceptance for forged tokens generated by guessing, using the optimal forging method using one measurement, using the direct inversion tomography with three measurements, the maximum likelihood method using one, two and three measurement.
* pf_2mBayesian.cpp This mpi-parallelized c++ program calculates the probability of acceptance of forged tokens generated by the Bayesian method using two measurements.
* pf_3mBayesian.cpp This mpi-parallelized c++ program calculates the probability of acceptance of forged tokens generated by the Bayesian method using three measurements.
* pf_2mfix.cpp This mpi-parallelized c++ program calculates the probability of acceptance of forged tokens generated by performing two measurements with N1 = N2 = N/2. The first one uses thetaf1 = 0, phif1 = 0 and the second one uses thetaf2 = pi/2, phif2 = 0.
* pf_3mfix.cpp This mpi-parallelized c++ program calculates the probability of acceptance of forged tokens generated by performing three measurements with N1 = N2 = N3 = N/3. The first one uses thetaf1 = 0, phif1 = 0 and the second one uses thetaf2 = pi/2, phif2 = 0 and the third one thetaf2 = pi/2, phif2 = pi/2.
* pf_2mopt.cpp This mpi-parallelized c++ program calculates the probability of acceptance of forged tokens generated by performing two measurements and testing all possible N1, N2 with N1 + N2 = N and N1 >= 1 and N2 >= 1 and all possible angles thetaf2 used in the second measurement on a defined grid. The result is written in a file which filename is provided in the control file.
* analyse_pf2mopt.cpp this c++ program reads in the file generated by the program pf_2mopt and determines, which is the optimal measurement scenario for two measurements.